// Code generated by "genprotocol -ver=68269c8bfeecd6e461aa862d64007f60a1aeccd64229d523ae7b99a446255112 -basedir=. -prefix=gos -statstype=int"

package gos_connwsgorilla

import (
	"context"
	"fmt"
	"net/url"
	"sync"
	"time"

	"github.com/gorilla/websocket"
	"github.com/kasworld/goonlinescaffolding/protocol_gos/gos_loopwsgorilla"
	"github.com/kasworld/goonlinescaffolding/protocol_gos/gos_packet"
)

type Connection struct {
	wsConn       *websocket.Conn
	sendRecvStop func()
	sendCh       chan gos_packet.Packet

	readTimeoutSec     time.Duration
	writeTimeoutSec    time.Duration
	marshalBodyFn      func(interface{}, []byte) ([]byte, byte, error)
	handleRecvPacketFn func(header gos_packet.Header, body []byte) error
	handleSentPacketFn func(header gos_packet.Header) error
}

func New(
	readTimeoutSec, writeTimeoutSec time.Duration,
	marshalBodyFn func(interface{}, []byte) ([]byte, byte, error),
	handleRecvPacketFn func(header gos_packet.Header, body []byte) error,
	handleSentPacketFn func(header gos_packet.Header) error,
) *Connection {
	tc := &Connection{
		sendCh:             make(chan gos_packet.Packet, 10),
		readTimeoutSec:     readTimeoutSec,
		writeTimeoutSec:    writeTimeoutSec,
		marshalBodyFn:      marshalBodyFn,
		handleRecvPacketFn: handleRecvPacketFn,
		handleSentPacketFn: handleSentPacketFn,
	}

	tc.sendRecvStop = func() {
		fmt.Printf("Too early sendRecvStop call")
	}
	return tc
}

func (tc *Connection) ConnectTo(connAddr string) error {
	u := url.URL{Scheme: "ws", Host: connAddr, Path: "/ws"}
	var err error
	tc.wsConn, _, err = websocket.DefaultDialer.Dial(u.String(), nil)
	if err != nil {
		return err
	}
	return nil
}

func (tc *Connection) Cleanup() {
	tc.sendRecvStop()
	if tc.wsConn != nil {
		tc.wsConn.Close()
	}
}

func (tc *Connection) Run(aictx context.Context) error {
	connCtx, ctxCancel := context.WithCancel(aictx)
	tc.sendRecvStop = ctxCancel
	var rtnerr error
	var sendRecvWaitGroup sync.WaitGroup
	sendRecvWaitGroup.Add(2)
	go func() {
		defer sendRecvWaitGroup.Done()
		err := gos_loopwsgorilla.RecvLoop(
			connCtx,
			tc.sendRecvStop,
			tc.wsConn,
			tc.readTimeoutSec,
			tc.handleRecvPacketFn,
		)
		if err != nil {
			rtnerr = err
		}
	}()
	go func() {
		defer sendRecvWaitGroup.Done()
		err := gos_loopwsgorilla.SendLoop(
			connCtx,
			tc.sendRecvStop,
			tc.wsConn,
			tc.writeTimeoutSec,
			tc.sendCh,
			tc.marshalBodyFn,
			tc.handleSentPacketFn,
		)
		if err != nil {
			rtnerr = err
		}
	}()
	sendRecvWaitGroup.Wait()
	return rtnerr
}

func (tc *Connection) EnqueueSendPacket(pk gos_packet.Packet) error {
	select {
	case tc.sendCh <- pk:
		return nil
	default:
		return fmt.Errorf("Send channel full %v", tc)
	}
}
